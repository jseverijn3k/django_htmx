# Simple webapp to see howfar we can stretch django and htmx before we need JavaScript.

The whole idea of this project is to build an **Instagram** like webapp:

* where you can post a Flickr (www.flickr.com) image -> using a Flickr link after which a webcrawler fetches the image and image info from Flickr.
* see a stream (on a screen) with the latest posts
* you can comment acpost and reply on a comment
* you can like posts, comments and replies

The project includes:

## Posts -> in a seperate django app

* Post information like image, author, etc..
* default avatars if no author is known (e.g. when a user leaves (deletes his profile). The posts are not deleted but the author is shown as 'no author'.
* CRUD functionality to view, create update and delete a post (using Django Forms).
* * infinite scroll on homepage and categroy pages using htmx

## A webcrawler to get images from Flickr.com -> as part of post functionality

* get images, artist name and artist url from Flickr
* use the BeautifulSoup package to build the webcrawler

## Messages (using Django messages)

* to show if an action was succesfull
  * Create / Update / Delete of a post
  * Delete of a comment
  * Delete of a reply

## Categories and Tag -> in Post app

* to tag our posts with a certain category
* using a many-to-many relationship between post and tags
* category filtering -> showing only the posts belonging to a certain category
* use category images
* enable a category order

## User authentication using Django-allauth package

* login
* logout
* signup
* password reset
* email verification after a signup
* styling of all allauth templates

## User profiles -> in a seperate django app

* one-to-one connection with the standard django user model
* profile pictures -> using Pillow package
* use django **signals** to synchronise imformation (email address) between the user profile and djangu standard user model
* use django-cleanup package to cleanup old profile pictures. So, we don't have old unused profile images on our server
* user profile pages, both private (for loggedin users) als public for all users
* username blacklist (in our settings.py file) to avoid conflicts with usernames
* use Django signals (post_save) to create a profile when a user object is added to teh database after a user signs up.
* use Django signals to update the user table when the email is changed on the profile page
* use a Django onboarding page that is shown directly after a user signsup

## Comments and replies -> in Post app

* Comments model -> with create, read and delete (only own comments) functionality.
  * for the create Django Forms is used
* Replies (to comments) model -> with create, read and delete (only own replies) functionality
  * for the create Django Forms is used
* show author next to comments and replies -> and linkl to the user profile

## Likes

* use **HTMX** -> hx-get, hx-target, hx-swap, snippets
* use a custom through table (with the created field) instead of the standrad throughtable generated by Django
* a user can only like a post once
* a user can not like his own posts
* a template snippet is made for the likes
* htmx is used to swap the the likes snippet when a user clicks (likes)
* likes on comments
* Likes on replies (to comments)
* use a **custom decorator** to avoid duplicating code for the like functionality

## Seamless and smooth integration when we add a comment or reply

* adding comments without refreshing the whole page using HTMX
* adding replies to comments without refreshing the whole page using HTMX
* use hyperscript (https://hyperscript.org/) after HTMX to remove comment/reply from the input field
* update the comments count automatically after adding a comment using HTMX (outerbound swap -> hx-swap-oob="true")
* use a fade in transition using hyperscript to animate the comment

## Newest posts and Top posts functionality

* use "?" selector in url
* use django_htmx package (https://django-htmx.readthedocs.io/en/latest/)
* use the annotate method to generate sql code for us to make calculations in the database. This is faster than in django... 
* use a database function (count) and store the value in a variable (num_likes) to show the comment with the most likes on top.

## Sidebar

* show a sidebar with the following items:
  * categories -> show the post tags  so users can click on them and see all posts in teh category.
  * top posts -> posts with the most likes
  * top comments -> posts with the most comments
* load the sidebar with a custom templatetag.
* make a custom templatetage to show the sidebar (which is used inon multiple pages) so we can remain DRY and dont need to add the same context variables in multiple views.
* use the pluralize templatetag to show like or likes depending on the number of likes.
* highlight the post in the top posts if the logged in user liked it.
* Key concepts: **custom templatetags**, inclusion_tag(), pluralize, truncatechars

## Inbox

* users can send (private) messages to each otehr using an inbox functionality
* users can send a mesage from the profiel page and the inbox
* users get a notification alert to see when they have new messages
* encryption of messages (also for admins) so the messages stay truly private
* make the messages immutable on the admin people so they cannot be changes there
* build as a standalone component 9meaning all files (also the template files) are in this folder

## Summary

Concepts used:

* allauth for user authentication
* htmx
* hyperscript
* messages
* signals
* custom decorators
* annotate method
* custom templatetags
* infinite scroll on pages with posts (home and category pages) using htmx
* inbox
